---
title: "Homework 1 - readable and efficient R code"
author: "Sophie Shan"
date: "`r format(Sys.time(), '%m/%d/%Y')`"
output:
  pdf_document: default
  html_document: default
---

```{r}
############################
#INSTALL AND LOAD PACKAGES 
############################
#install
#install.packages("microbenchmark")

#load 
library("microbenchmark")
```


# Question 1 - "function-alize" this code

```{r}
############################
#GENERATE DATA 
############################
set.seed(1)
x <- rnorm(100)
z <- rnorm(100)
```


```{r}
############################
#ORIGINAL CODE 
############################
if (sum(x >= .001) < 1) {
  stop("step 1 requires 1 observation(s) with value >= .001")
}
fit <- lm(x ~ z)
r <- fit$residuals
x <- sin(r) + .01
if (sum(x >= .002) < 2) {
  stop("step 2 requires 2 observation(s) with value >= .002")
}
fit <- lm(x ~ z)
r <- fit$residuals
x <- 2 * sin(r) + .02
if (sum(x >= .003) < 3) {
  stop("step 3 requires 3 observation(s) with value >= .003")
}
fit <- lm(x ~ z)
r <- fit$residuals
x <- 3 * sin(r) + .03
if (sum(x >= .004) < 4) {
  stop("step 4 requires 4 observation(s) with value >= .004")
}
fit <- lm(x ~ z)
r <- fit$residuals
x <- 4 * sin(r) + .04
x
```

* Wrap it into a function `foobar0` which has arguments `x` and `z`
  and which returns the vector `x` at the end of the following code.
  
```{r}
############################
#MY FUNCTION: foobar0
############################
foobar0 <- function(x, z){
  
  #first iteration 
  if (sum(x >= .001) < 1) {
    stop("step 1 requires 1 observation(s) with value >= .001")
    }
  fit <- lm(x ~ z)
  r <- fit$residuals
  x <- sin(r) + .01
  
  #second iteration 
  if (sum(x >= .002) < 2) {
    stop("step 2 requires 2 observation(s) with value >= .002")
    }
  fit <- lm(x ~ z)
  r <- fit$residuals
  x <- 2 * sin(r) + .02
  
  #third iteration
  if (sum(x >= .003) < 3) {
      stop("step 3 requires 3 observation(s) with value >= .003")
    }
  fit <- lm(x ~ z)
  r <- fit$residuals
  x <- 3 * sin(r) + .03
    
  #fourth iteration 
  if (sum(x >= .004) < 4) {
      stop("step 4 requires 4 observation(s) with value >= .004")
    }
  fit <- lm(x ~ z)
  r <- fit$residuals
  x <- 4 * sin(r) + .04
  
  #return the vector 
  x
}
```

* Rewrite this into a function `foobar` which is easier to read, by
  reducing repetitive code. E.g. `foobar` might call a function to
  check the input, and another function to perform the three lines of
  computation. 

```{r}
############################
#MY FUNCTION: foobar
############################
#call the function to check the input 
check_input <- function(x, i){
  
  if(sum(x >= .001*i) < i){
    stop(paste0("step ", i, " requires ", i, " observation(s) with value >= ", .001*i))
  }
  
}

#perform the three lines of computation 
perform_computation <- function(x, z, i){
  
  fit <- lm(x~z)
  r <- fit$residuals
  x <- i * sin(r) + .01 * i 
  
  #return 
  x
  
}
  
#put it all together 
foobar <- function(x, z){
  for(i in 1:4){
    #check the input 
    check_input(x, i)
    #perform the computation
    x <- perform_computation(x, z, i)
  }
  
  #return x
  x
}
```

* Check that the two versions produce the same output using the
  function `all.equal`.
  
```{r}
############################
#CHECK THAT THE FUNCTIONS HAVE THE SAME OUTPUT 
############################
#first function 
foobar0_output <- foobar0(x,z)

#second function 
foobar_output <- foobar(x,z)

#equal?
all.equal(foobar0_output, foobar_output)
```

# Question 2 - vectorize this code and benchmark

* Take the following function `f0` and rewrite it as a function `f`,
  which is faster and easier to read, by removing the loop of `i` from
  1 to `m`.
  
```{r}
############################
#GENERATE DATA 
############################
n <- 30
p <- 50
p2 <- 25
m <- 1000
set.seed(1)
x <- matrix(rnorm(n*p),nrow=n,ncol=p)
b <- matrix(rnorm(m*p),nrow=m,ncol=p)
a <- matrix(rnorm(m*p2),nrow=m,ncol=p2)
```

```{r}
############################
#ORIGINAL FUNCTION
############################
f0 <- function(x,b,a) {
  out <- numeric(0)
  for (i in seq_len(m)) {
    bb <- b[i,]
    aa <- a[i,]
    out <- c(out, sum(x %*% bb) + sum(aa))
  }
  out
}
```

```{r}
############################
#MY FUNCTION 
############################
f <- function(x,b,a){
  
  #vectorize sum(x %*% bb)
  first_part <- colSums(x %*% t(b))
  
  #vectorize sum(aa)
  second_part <- rowSums(a)
  
  #add them together
  out <- first_part + second_part
  
  #return the output 
  out
}
```

```{r}
############################
#CHECK THAT THE FUNCTIONS HAVE THE SAME OUTPUT 
############################
#original 
f0_outcome <- f0(x,b,a)

#mine 
f_outcome <- f(x,b,a)

#equal?
all.equal(f0_outcome, f_outcome)
```

* Benchmark `f` and `f0` using `microbenchmark`. How much faster is `f`?
```{r}
############################
#BENCHMARK 
############################
microbenchmark(f0(x,b,a), f(x,b,a))

#f is 5 times faster than f0
```

# Question 3 - build a faster t-test

```{r}
############################
#GENERATE DATA 
############################
m <- 400
n <- 50
little.n <- n/2
set.seed(1)
x <- matrix(rnorm(m*n),nrow=m,ncol=n)
f <- gl(2,little.n)
```


```{r}
############################
#ORIGINAL FUNCTION
############################
getT0 <- function(x, f) {
  ts <- sapply(seq_len(m), function(i) t.test(x[i,] ~ f, var.equal=TRUE)$statistic)
  unname(ts)
}
```

* Rewrite the following function `getT0` which computes `m`
  two-sample t-tests (equal variance) between two groups as a function
  `getT`, which is faster by using vectorized operations over the `m`
  sets of observations. (There are functions in R packages, such as
  `genefilter::rowttests` which will quickly perform this operation,
  but I want you to write your own function using simple R functions
  like `rowSums`, etc.)
  
Recall that the t-statistic for two-sample t-test with equal variance is:
$$t = \frac{(\bar{x}_1 - \bar{x}_2) - (\mu_1 - \mu_2)}{ \sqrt{s_p^2 (\frac{1}{n_1} + \frac{1}{n_2})}}$$

where $$s_p^2 = \frac{(n_1 - 1) s_1^2 + (n_2 - 1)s_2^2}{n_1 + n_2 - 2}$$
where $s_1$ and $s_2$ are the sample standard deviations. 

Citation for equations: https://www.theopeneducator.com/doe/hypothesis-Testing-Inferential-Statistics-Analysis-of-Variance-ANOVA/Two-Sample-T-Test-Equal-Variance

```{r}
############################
#MY FUNCTION 
############################

getT <- function(x, f){
  
  #separate into the two groups 
  group_1 <- x[,f == "1"]
  group_2 <- x[,f == "2"]
  
  #get the size for the two groups 
  n_1 <- dim(group_1)[2]
  n_2 <- dim(group_2)[2]

  #mean of the the two groups 
  mean_1 <- rowSums(group_1)/n_1
  mean_2 <- rowSums(group_2)/n_2
  
  #sample standard deviation
  std_1 <- apply(group_1, MARGIN = 1, FUN = sd)
  std_2 <- apply(group_2, MARGIN = 1, FUN = sd)
  
  #pooled standard error 
  std_error_sqrd <- ((n_1-1)*std_1^2 + (n_2-1)*std_2^2)/(n_1+n_2-2)
  
  #numerator: t-statistic
  num <- mean_1-mean_2
  
  #denominator: t-statistic 
  denom <- sqrt(std_error_sqrd*((1/n_1)+(1/n_2)))
  
  #calculate the t-statistic
  t_stat <- num/denom
  
  #return the t-statistic 
  t_stat
}
```

  
```{r}
############################
#CHECK THAT THE FUNCTIONS HAVE THE SAME OUTPUT 
############################
#original 
getT0_output <- getT0(x, f)

#mine 
getT_outcome <- getT(x, f)

#equal?
all.equal(getT0_output, getT_outcome)
```  
  
* Benchmark `getT` and `getT0`. How much faster is `getT`?

```{r}
############################
#BENCHMARK 
############################
microbenchmark(getT0(x, f), getT(x, f))

#getT is 20 times faster than getT0
```